# :흰색_확인_표시: 1. 그리디 알고리즘 (Greedy Algorithm)
### :작은_파란색_다이아몬드: 개념
그리디 알고리즘은 매 순간 가장 좋아 보이는 선택을 하는 방식으로 문제를 해결하는 기법이야.
즉, 현재 상황에서 최적이라고 생각되는 선택을 반복해서 전체 문제의 최적해를 찾는 것이 목표야.
단, 모든 문제에 적용할 수 있는 건 아니고, ‘**탐욕스러운 선택이 전체 최적해로 이어지는 조건**’을 만족해야 해.
### :작은_파란색_다이아몬드: 예제 문제
[동전 거스름돈 문제]
손님에게 거슬러 줘야 할 돈이 있을 때, 가장 적은 수의 동전으로 거슬러 주는 방법을 구하자.
(단, 동전은 500원, 100원, 50원, 10원으로만 구성되어 있음)
### :작은_파란색_다이아몬드: 예시 코드
```c++
int coins[] = {500, 100, 50, 10};
int change = 1260;
int cnt = 0;
for (int coin : coins) {
    cnt += change / coin;
    change %= coin;
}
cout << cnt;
```
- 조건이 만족하지 않는 경우 coins[]가 {4,3,1}(ex_6원) 등으로 이루어져 있을때
### :작은_파란색_다이아몬드: 활용
브루트포스/백트킹과의 혼합
예시) 단어 수학
### :작은_파란색_다이아몬드: 비교
`DP`
- :작은_파란색_다이아몬드:반례가 존재하면 그리디를 쓴것이다
- :작은_파란색_다이아몬드:주어지지않은 임의의 조건을 사용하는 순간 그리디를 사용한 것이다
- :작은_파란색_다이아몬드:그리디는 많은 곳에 적용된다.
- 스택 알고리즘 문제 중 “창고 다각형“과 같은 문제도 `그리디 알고리즘`을 사용한 문제이다.
# :흰색_확인_표시: 2. 투 포인터 알고리즘 (Two Pointer Algorithm)
### :작은_파란색_다이아몬드: 개념
투 포인터는 두 개의 포인터를 사용해 문제를 해결하는 방식이야.
보통 정렬된 배열이나 리스트에서 구간, 부분합, 쌍(pair)을 다룰 때 사용돼.
두 포인터는 일반적으로 시작점과 끝점을 의미하며,
필요에 따라 이동시켜 조건을 만족하는 구간을 찾는 것이 핵심이야.
### :작은_파란색_다이아몬드: 예제 문제
- 정렬된 배열에서 특정 합을 가지는 두 수 찾기
- 정렬된 리스트에서 두 수를 더해서 특정 값이 되는 쌍이 있는지 확인하자.
### :작은_파란색_다이아몬드: 예시 코드
```c++
    // 두용액
    int i=0;
    int j=num-1;
    while(i<j)
    {
        value = arr[i]+arr[j];
        if(num_min>abs(value))
        {
            num_min = abs(value);
            if(num_min<ans)
            {
                ans=num_min;
                arr_ans[0]=arr[i];
                arr_ans[1]=arr[j];
                if(ans==0)
                    break;
            }
        }
        if(value<0)
            i++;
        else
            j--;
    }
```